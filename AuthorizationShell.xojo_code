#tag ClassProtected Class AuthorizationShell	#tag Method, Flags = &h0		Function AuthorizeAndExecute(pathToTool as String, args() as String) As Boolean		  Declare function AuthorizationCreate lib "Security" (rights as integer, environment as integer, flags as Integer, byref ref as Integer) as Integer		  declare function AuthorizationCopyRights lib "Security" (ref as Integer, rightSet as Ptr, environment as Integer, flags as Integer, i as integer) as Integer		  declare function AuthorizationExecuteWithPrivileges lib "Security" (ref as Integer, pathToTool as CString, options as Integer, arguments as Ptr, byref pipe as Integer) as Integer		  declare function fclose lib "/usr/lib/libc.dylib" (file as Integer) as Integer		  declare function fcntl lib "/usr/lib/libc.dylib" (file as integer, cmd as integer, param as integer) as integer		  declare function fileno lib "/usr/lib/libc.dylib" (file as integer) as integer		  		  dim err as integer		  		  dim i,c as integer		  c = UBound(args)		  dim argsBlock as new MemoryBlock((c+2)*4)		  dim cstrs(-1) as MemoryBlock		  		  // put pointers to CStrings into the arguments block		  // it's the size of the number of arguments + 1		  // because the argv style is that it will read memory until		  // one null pointer		  		  // This operation requires that your args are provided as a		  // string array		  		  for i = 0 to c		    cstrs.Append args(i) + chr(0)		    argsBlock.Ptr(i*4) = cstrs(i)		  next		  		  // If we already have an authorization ref, we might as well reuse it		  if authRef = 0 then		    err = AuthorizationCreate( 0, 0, 0, authRef)		    		    if err <> 0 then		      errNum = err		      return false		    end if		  end if		  		  // Try to authorize and execute the tool		  err = AuthorizationExecuteWithPrivileges( authRef, pathToTool, 0, argsBlock, file )		  		  // Check for an error.		  if err <> 0 then		    // User cancelled if error is -60006		    if err = -60006 then		      errNum = 0		    else		      errNum = err		    end if		    		    // couldn't authorize, return false		    return false		  end if		  		  // Get the file descriptor number		  dim filenum as integer = fileno(file)		  		  // Grab the flags to the file		  err = fcntl(filenum, 3, 0)		  // BitwiseOr the number with 4 (non-blocking)		  err = Bitwise.bitOr(err, 4)		  // Re-set the flags on the file		  err =  fcntl(filenum, 4, err)		  		  // Reset the flags so that we handle other methods fine		  IsLive = true		  errNum = 0		  		  // We were successful		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  declare sub AuthorizationFree lib "Security" ( ref as integer, flags as integer) 		  		  // If we have an authRef, free it		  if authRef <> 0 then		    AuthorizationFree( authRef, 8 )		    authRef = 0		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ErrorNumber() As Integer		  // since the error number shouldn't be writable,		  // we just have an accessor method for it.		  return errNum		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Poll()		  declare function fread lib "/usr/lib/libc.dylib" (buffer as Ptr, size as integer, nmemb as integer, stream as Integer) as Integer		  declare function feof lib "/usr/lib/libc.dylib" (file as Integer) as boolean		  declare function fclose lib "/usr/lib/libc.dylib" (file as Integer) as Integer		  declare function ferror lib "/usr/lib/libc.dylib" (file as integer) as Integer		  		  // create a local buffer		  // if this gets called a lot, we should consider		  // changing this to be a property on the class		  // and possibly increasing the size		  // However, 1024 seems like an OK chunk size for now		  dim localBuffer as new MemoryBlock(1024)		  dim err as Integer		  		  // Make sure that we're live		  if isLive then		    // Just satisfy the loop condition to begin with		    err = 1024		    // Basically the idea is that we'll loop until it gives us		    // back less than the full buffer. When it retuns less than		    // our buffer size, either it's EOF, or an error occurred, 		    // or we're just fine (EAGAIN)		    while err = 1024		      // read from the file into our buffer		      err = fread(localBuffer, 1, 1024, file)		      // add the local buffer to our real buffer		      buffer = buffer + localBuffer.StringValue(0,err)		    wend		    		    // If we are at the EOF		    if feof(file) then		      // then we need to close the file		      err = fclose(file)		      // fire the completed event		      Completed		      // And make it so that we aren't live anymore		      IsLive = false		      		    elseif err <= -1 then // we may have a problem		      // Read the error number		      errNum = ferror(file)		      		      // 35 is the number for EAGAIN -- in Non-blocking mode,		      // it's used to signify that the file isn't ended		      // and we need to try, try again later		      if errNum = 35 then 		        // just no data this time		        errNum = 0		      else		        // We have an error		        IsLive = false		        call fclose(file)		      end if		    end if		  end if		  		  // if we have any data available, we should fire the DataAvailable event		  if lenb(buffer) > 0 then		    DataAvailable		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ReadAll() As String		  // This method simply returns the buffer		  // and then clears it out		  // we have to do some swapping because we can't return something,		  // then clear the string afterwards -- hence the slightly strange code		  dim s as string		  s = buffer		  buffer = ""		  return s		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Result() As String		  // This method simply returns the buffer without clearing		  // the contents		  		  return buffer		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Write(s as string)		  declare function fwrite lib "/usr/lib/libc.dylib" (buffer as CString, size as integer, num as integer, stream as Integer) as integer		  		  // We can only write to a live connection		  if isLive then		    // Write the string		    call fwrite(s, 1, lenb(s), file)		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteLine(s as string)		  // We assume that our shell is Mac OS X only for now		  // and we simply call through to write		  Write s + EndOfLine.UNIX		End Sub	#tag EndMethod	#tag Hook, Flags = &h0		Event Completed()	#tag EndHook	#tag Hook, Flags = &h0		Event DataAvailable()	#tag EndHook	#tag Note, Name = Usage and Update Info		This authorization module was originally written by Jon Johnson		while he worked at REALSoftware.				There was an issue in the manner in which the AuthorizeAndExecute		function was designed as it expected a ParamArray (VARARGS) for		the command arguments to be passed to the function.  However, it 		was trying to separate the arguments from an array.  I've modified 		that expectation to use a String Array - which is a lot easier		for most RB programmers to create and understand.				Additionally, I've duplicated all of the normal Shell events and 		methods to allow you to basically drop an AuthorizationShell into		any app by simply changing your Shell controls' super.				These are the only changes that I've made to Jon's original coding for 		this module.				To use it, simply copy this class module into your application and		create a subclassed control.				You should create a Mode 0 Timer on your window with the period 		set at 10ms to 25ms and enable it just before you call the		AuthorizeAndExecute Method.  Its Action event should simply call		your subclassed class' Poll method.  Finally, Add the necessary 		code to your subclassed DataAvailable event and make sure that you		reset the polling timer's mode to 0 in the Completed event.				The Window1 window has been added and all of the details of the		call are outlined in the pbAuthenticate button's Action event.				The code there that splits the commandline passed was created to 		simply demonstrate the numerous ways that a command line's args		may be constructed - quote pairs, tick pairs, escaped spaces,		and others.  I'm sure that the example doesn't cover 100% of the 		possibilities, but it should give you a relatively good starting		point.				The only things that are necessary is that you pass the full path		to your command (i.e.: /bin/cp instead of simply cp) and a string 		array of the arguments - one argument per array member.				Aug 24, 2008 - Tim Jones, tolistim@me.com					#tag EndNote	#tag Property, Flags = &h21		Private authRef As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private buffer As String	#tag EndProperty	#tag Property, Flags = &h21		Private bufLen As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private errNum As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private file As Integer	#tag EndProperty	#tag Property, Flags = &h0		IsLive As Boolean	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			Type="Integer"			EditorType=""		#tag EndViewProperty		#tag ViewProperty			Name="IsLive"			Visible=false			Group="Behavior"			InitialValue="0"			Type="Boolean"			EditorType=""		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			EditorType=""		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InitialValue=""			Type="String"			EditorType=""		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InitialValue=""			Type="String"			EditorType=""		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			EditorType=""		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass